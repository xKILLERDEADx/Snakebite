"""Automated Exploit Reporter — generate CVSS scores, PoC, remediation."""

import json
import hashlib
from datetime import datetime
from modules.core import console

CVSS_MAP = {
    'Critical': {'score': 9.5, 'vector': 'AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H'},
    'High': {'score': 7.5, 'vector': 'AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N'},
    'Medium': {'score': 5.0, 'vector': 'AV:N/AC:L/PR:N/UI:R/S:U/C:L/I:L/A:N'},
    'Low': {'score': 3.0, 'vector': 'AV:N/AC:H/PR:L/UI:R/S:U/C:L/I:N/A:N'},
    'Info': {'score': 0.0, 'vector': 'AV:N/AC:H/PR:H/UI:R/S:U/C:N/I:N/A:N'},
}


REMEDIATION_DB = {
    'sql': {
        'title': 'SQL Injection Remediation',
        'steps': [
            'Use parameterized queries / prepared statements',
            'Implement input validation with whitelist approach',
            'Use ORM (SQLAlchemy, Hibernate, Eloquent)',
            'Apply least privilege principle on DB user',
            'Enable WAF rules for SQL injection patterns',
        ],
    },
    'xss': {
        'title': 'XSS Remediation',
        'steps': [
            'Encode all output (HTML entity encoding)',
            'Implement Content-Security-Policy header',
            'Use HttpOnly and Secure cookie flags',
            'Sanitize input with DOMPurify or similar',
            'Use framework auto-escaping (React, Angular, Vue)',
        ],
    },
    'ssrf': {
        'title': 'SSRF Remediation',
        'steps': [
            'Validate and sanitize all URLs before fetching',
            'Block internal IP ranges (127.0.0.0/8, 10.0.0.0/8, 169.254.x.x)',
            'Use allowlist for permitted domains',
            'Disable unnecessary URL schemes (file://, gopher://)',
            'Implement network segmentation',
        ],
    },
    'header': {
        'title': 'Security Headers Remediation',
        'steps': [
            'Add Strict-Transport-Security: max-age=31536000; includeSubDomains',
            "Add Content-Security-Policy with strict sources",
            'Add X-Content-Type-Options: nosniff',
            'Add X-Frame-Options: SAMEORIGIN',
            'Add Referrer-Policy: strict-origin-when-cross-origin',
        ],
    },
    'auth': {
        'title': 'Authentication Remediation',
        'steps': [
            'Implement multi-factor authentication (MFA)',
            'Use bcrypt/argon2 for password hashing',
            'Set account lockout after N failed attempts',
            'Implement CSRF tokens on all state-changing requests',
            'Use secure session management with short timeouts',
        ],
    },
    'default': {
        'title': 'General Security Remediation',
        'steps': [
            'Keep all software and dependencies updated',
            'Implement defense in depth strategy',
            'Regular security assessments and penetration testing',
            'Enable comprehensive logging and monitoring',
            'Follow OWASP Top 10 guidelines',
        ],
    },
}


def _classify_finding(finding_type):
    """Classify a finding to match remediation category."""
    ft = finding_type.lower()
    if any(k in ft for k in ['sql', 'sqli', 'injection', 'database']):
        return 'sql'
    if any(k in ft for k in ['xss', 'cross-site', 'script', 'dom']):
        return 'xss'
    if any(k in ft for k in ['ssrf', 'server-side request', 'redirect']):
        return 'ssrf'
    if any(k in ft for k in ['header', 'hsts', 'csp', 'cors', 'x-frame']):
        return 'header'
    if any(k in ft for k in ['auth', 'password', 'login', 'session', 'jwt', 'oauth']):
        return 'auth'
    return 'default'


def _generate_poc(finding):
    """Generate proof of concept for a finding."""
    ftype = finding.get('type', '').lower()
    url = finding.get('url', finding.get('src', 'TARGET_URL'))
    param = finding.get('param', 'PARAM')
    payload = finding.get('payload', finding.get('evidence', ''))

    if 'sql' in ftype:
        return f"curl -s '{url}?{param}=%27%20OR%201%3D1--' -o /dev/null -w '%{{http_code}}'"
    elif 'xss' in ftype:
        return f"curl -s '{url}?{param}=%3Cscript%3Ealert(1)%3C/script%3E' | grep '<script>'"
    elif 'ssrf' in ftype:
        return f"curl -s '{url}?{param}=http://169.254.169.254/latest/meta-data/'"
    elif 'header' in ftype:
        return f"curl -sI '{url}' | grep -i 'strict-transport-security\\|content-security-policy'"
    elif 'pickle' in ftype:
        return f"curl -s '{url}?{param}=gASVIQAAAAAAAACMBHRpbWWUjAVzbGVlcJSTlEsFhZRSlC4='"
    elif any(k in ftype for k in ['admin', 'username', 'user']):
        return f"curl -s '{url}/wp-json/wp/v2/users' | python -m json.tool"
    elif 'xml-rpc' in ftype or 'xmlrpc' in ftype:
        return f"curl -s -X POST '{url}/xmlrpc.php' -d '<methodCall><methodName>system.listMethods</methodName></methodCall>'"
    else:
        return f"# Manual verification required for: {finding.get('type', 'Unknown')}"


def _generate_finding_id(finding):
    """Generate a unique ID for a finding."""
    raw = f"{finding.get('type', '')}-{finding.get('url', '')}-{finding.get('param', '')}"
    return hashlib.md5(raw.encode()).hexdigest()[:8].upper()


async def scan_exploit_report(session, url, full_report=None):
    """Generate professional exploit report with CVSS and PoC."""
    console.print(f"\n[bold cyan]--- Automated Exploit Reporter ---[/bold cyan]")

    if not full_report:
        console.print(f"  [dim]No scan data to generate report from[/dim]")
        return {'report': []}

    all_findings = []

    vuln_data = full_report.get('vulnerabilities', {})
    for module_name, results in vuln_data.items():
        if isinstance(results, list):
            for finding in results:
                if isinstance(finding, dict):
                    all_findings.append({**finding, 'module': module_name})
        elif isinstance(results, dict):
            for key, items in results.items():
                if isinstance(items, list):
                    for finding in items:
                        if isinstance(finding, dict):
                            all_findings.append({**finding, 'module': module_name})

    for key in ['recon', 'cms', 'ports', 'subdomains']:
        data = full_report.get(key, {})
        if isinstance(data, dict):
            missing_headers = data.get('security_headers', {}).get('missing', [])
            if isinstance(missing_headers, list):
                for header in missing_headers:
                    if isinstance(header, dict):
                        all_findings.append({
                            'type': f'Missing Header: {header.get("name", "?")}',
                            'severity': header.get('severity', 'Medium'),
                            'module': 'recon',
                        })

    report_entries = []
    severity_order = {'Critical': 0, 'High': 1, 'Medium': 2, 'Low': 3, 'Info': 4}

    for finding in all_findings:
        severity = finding.get('severity', 'Medium')
        if severity not in CVSS_MAP:
            severity = 'Medium'

        cvss = CVSS_MAP[severity]
        category = _classify_finding(finding.get('type', ''))
        remediation = REMEDIATION_DB.get(category, REMEDIATION_DB['default'])

        entry = {
            'id': _generate_finding_id(finding),
            'title': finding.get('type', 'Unknown Vulnerability'),
            'severity': severity,
            'cvss_score': cvss['score'],
            'cvss_vector': cvss['vector'],
            'module': finding.get('module', 'unknown'),
            'url': finding.get('url', url),
            'param': finding.get('param', ''),
            'evidence': finding.get('evidence', finding.get('detail', '')),
            'poc': _generate_poc(finding),
            'remediation': remediation,
        }
        report_entries.append(entry)

    report_entries.sort(key=lambda x: severity_order.get(x['severity'], 5))

    stats = {
        'total': len(report_entries),
        'critical': len([e for e in report_entries if e['severity'] == 'Critical']),
        'high': len([e for e in report_entries if e['severity'] == 'High']),
        'medium': len([e for e in report_entries if e['severity'] == 'Medium']),
        'low': len([e for e in report_entries if e['severity'] == 'Low']),
    }

    console.print(f"\n  [bold]Exploit Report Summary:[/bold]")
    console.print(f"  [red]Critical: {stats['critical']}[/red] | [yellow]High: {stats['high']}[/yellow] | "
                  f"[blue]Medium: {stats['medium']}[/blue] | [dim]Low: {stats['low']}[/dim]")
    console.print(f"  [bold]Total Findings: {stats['total']}[/bold]")

    if stats['critical'] > 0:
        console.print(f"\n  [bold red]Top Critical Findings:[/bold red]")
        for entry in report_entries[:5]:
            if entry['severity'] == 'Critical':
                console.print(f"  [red]• [{entry['id']}] {entry['title']} (CVSS {entry['cvss_score']})[/red]")

    return {
        'stats': stats,
        'report': report_entries,
        'generated_at': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
    }
